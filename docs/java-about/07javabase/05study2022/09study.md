---
title: 09study
---

## 1.ACID靠什么保证

A原子性：由undo log日志保证，记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql

C:一致性，由其它三大特性保证、程序代码要保证业务上的一致性

I：隔离型，由Mvcc来保证

D：持久性：由内存加redo log来保证，mysql修改数据同时，在内存和redo log记录操作，宕机时可以从redo log恢复

`InnoDb redo log 写盘，InnoDB事务进入prepare状态。
如果前面的prepare成功，binlog写盘，再继续将事务持久化到binlog，如果持久化成功，那么InnoDB事务则进入commit状态（在redo log里面写一个commit记录）`

redolog的刷盘会在系统空闲时进行

## 2.mysql聚簇和非聚簇索引

都是B+树的数据结构

- 聚簇索引：将数据和索引放在一块、并且按照一定的顺序组织，找到索引也就找到数据，数据的物理存放顺序和索引顺序是一致的，只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的
- 非聚簇索引：叶子节点不存储数据、储存的是数据地址，也就是说根据索引查找数据行的位置，再取磁盘查找数据，

> 优势：
>
> 1.通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询
>
> 2.聚簇索引对于范围查找效率很高，因为其数据是按照大小排序的
>
> 3.聚簇索引适合用在排序的场合，非聚簇索引不适合
>
> 劣势：
>
> 1.维护索引昂贵
>
> 2.表应为uuid（随机id）作为主键，使数据存储稀疏，
>
> 3.主键比较大的话，辅助索引将会变的更大，因为辅助索引的叶子存储的是主键索引，过长的主键会导致叶子节点占用更多的物理空间

InnoDB中一定有主键，主键一定是聚簇索引，

## 3。Mysql 慢查询如何优化

- 检查是否走索引，如果没有则优化利用索引
- 检查所利用的索引，是否是最优索引
- 检查所查询的字段是否都是必须的，是否查询了过多的字段，查询了多余数据
- 检查表中的数据是否过多，是否应该进行分库分表
- 检查数据库实例所在机器性能配置，是否太低，是否可以适当增加资源

## 4. mysql索引的数据结构，各自的优劣

## 5.mysql锁的类型有哪些

- 基于锁的属性分类：共享锁，排他锁
- 基于锁的粒度分类：行级锁、表级锁、页级锁、间隙锁、临建锁
- 基于锁的状态：意向锁，意向排他锁



- 共享锁（share lock）
  - 共享锁又称读锁，简称S锁，当一个事务为数据加上读锁后，其它事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放后，其它事务才能对其加持写锁。共享锁的特性主要是为了支持并发的读取数据，读区数据时不支持修改，避免出现重复读的问题。
- 排他锁（eXclusive Lock）
  - 排他锁又称写锁，简称X锁，当一个事务为数据加上写锁时，其它请求将不能为数据加任何锁，直到该锁释放后，其它事务才能对数据进行加锁。怕他锁的目的是为了在修改数据时，不允许其它人同时修改数据，也不允许其它人读数据。避免出现脏数据和脏读的问题。
- 表锁：上锁的时候锁住的时整个表，当下一个事务访问该表时，必须等当前一个事务释放了锁才能进行访问
  - 特点：粒度大、加锁简单、容易冲突
- 行锁：上锁的时候锁住表的某一行或者多行，
  - 特点：粒度小、加锁比较麻烦，不容易冲读，相比表锁支持的并发更高
- 记录锁：属于行锁的一种，
- 页锁：
- 间隙锁 行锁的一种
- 临建锁：行锁的一种

如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁，你门不能对整个表加共享锁或者怕他锁，那么后面需要对整个表加锁的人只需要获取这个状态就知道自己是不是可以对表加锁，避免了对整个索引树的美个节点扫面是否加锁，而这个状态就是意向锁。

- 意向共享锁：当一个事务试图对整个变加共享锁之前，首先需要获取意向共享锁
- 意向排他锁：当一个事务试图对整个表加排他锁，首先需要获取这个表的意向排他锁



## 6.mysql有哪几种存储引擎，区别

Mysql中通过show engines 可以查看支持的数据存储引擎，最常用的就是MyISAM和InnoDB

区别：

1.存储文件，MyISAM每个表有两个文件，（MyD，数据文件，MYISam，索引文件、表结构文件）InnoDB文件，只有一个文件idb

2，InnoDb支持事务，支持行级锁，外建

3.InnoDb支持XA事务

4、InnoDb支持savePoints

## 7.什么是mvcc

多版本并发控制：读区数据时，通过一种类似块皂的方式将数据保存下来，这样，读锁和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链

MVCC只在Read Committed和Repeatable Read两个隔离级别喜爱工作。其它两个隔离级别和mvcc不兼容，

## 4.事务的基本特性和隔离级别

事务的基本特性：

- 原子性：指一个事务中的操作要么全部成功，要么全部失败。
- 一致性：指的是数据库总是从一个一致性的状态，转换到另一个一致性的状态。
- 隔离性：一个事务的修改在最总提交前，对其它事务不可见
- 持久性：一旦事务提交，所做的修该就会永远保存到数据库中，

隔离性的四个级别：

- read uncommit 读未提交，可能读到其它事务未提交的数据。也叫脏读。
- read commit 读已提交，两次读区结果不一致，也叫不可重复读。
  - 不可重复读解决了脏读的问题，只会读区已经提交的事务。
- repetable read 可重复读，mysql默认级别，每次读区结果都一样，可能产生幻读
- serializable 串行，一般是不会使用的，给每一个行读区的数据加锁，会导致大量的超时和锁竞争

脏读：某个事务已经更新一份数据，另一个事务在此时读取了同一份数据，由于某种原因，前一个事务RollBack了操作，则后一个事务所读取的就会是不正确的。

不可重复读（non-repeatable read）：在一个事务的两次查询之中，数据不一致，这可能是两次查询过程中插入了事务更新的原有的数据

幻读（phantom read） 在一个事务的两次查询中数据不一致，如有一个事务查询了几列数据，而另一个事务却在此时插入了新的几列数据，先前的事务再次查询时，会发现有几列是之前查询没有的。

## 9.索引的基本原理

索引用来快速查询具有特定值的记录。如果没有索引，一般来说执行查询时会遍历整张表

索引的原理：把无序的数据变成有序的查询

1.创建了索引的列的内容进行排序

2.对排序结果生成倒排表

3.在倒排表内容上拼上数据地址链

4.查询时，先查询到排表内容，在取出数据地址链，从而拿到具体数据

## 48索引的设计原则

## 49怎么处理慢查询

## 50最左前缀原则

当一个sql想要利用索引时m

## 51redis单线程为什么这么快

## 52redis的持久化机制

RDB：redis database 将某一时刻的内存快照，以二进制的的方式写入磁盘

手动触发：

- save命令：使redis处理阻塞状态，知道rdb持久化完成，才会响应其它客户段的命令，所以在生成环境下一定要慎用。
- bgsave命令：fork一个子进程进行持久化，主进程只有在fork过程只能有短暂的阻塞，子进程创建后，主进程就可以响应客户端的命令

自动触发：

	- save m n 在m秒内如果n个建发生个giab，会自动触发，执行bgsve命令。在配置文件中配置
	- flushall：清空所有数据库，
	- 主从同步：全量同步时，会自动触发bgsave命令

优点：

- 整个redis数据库，只包含一个dump。rdb文件，方便持久化
- 容灾性好，方便备份
- 性能较好，fork子进程来完成写操作

缺点：

- 数据安全低



aof： append only file，以日志的形式记录所处理的每一个写、删操作，以文本的方式记录，可以打开文件查看详细的操作记录，掉操作系统命令进行刷盘

1.所有的命令都会追加到aof

2.aof缓冲区更具对应的策略向硬盘进行同步。

3.随着aof文件越来越大，需要定期对aof文件进行重写，达到压缩的目的

4.redis重启时，可以加载aof文件进行数据恢复

同步策略；

- 每秒同步：异步完成
- 每修改同步：同步持久化，
- 不同步：又操作系统控制，可能丢失数据，

优点：

数据安全

通过追加的方式，添加命令，即使服务器中图宕机，可以通过redis-chekc-aof工具解决数据一致性问题

aof机制的rewrite模式，定期对aof进行重写，以达到压缩的目的



缺点：

aof文件大，恢复速度慢

数据大时，redis启动效率低

运行效率没有rdb高